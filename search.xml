<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Swift基础-Result介绍]]></title>
    <url>%2F2019%2F05%2F02%2FSwift%E5%9F%BA%E7%A1%80-Result%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Result简介Result是Swft 5.0中新加入枚举值，Apple的官方文档定义如下： A value that represents either a success or a failure, including an associated value in each case. 翻译过来就是Result是一个只有success或failure的枚举，每个case都有关联值。 Result的用途Result主要用于异步block内抛出错误，详见SE0235。 异步block抛出错误的场景在日常开发中是非常见的，最典型的就是异步I/O操作，本文将以异步读取网络数据为例进行讨论。假设现在我们存在如下的异步读取网络数据代码： 12345678910111213141516171819202122232425class SimpleAsyncFetchDataDemo &#123; var queue: DispatchQueue init() &#123; self.queue = DispatchQueue(label: "com.wooy.swift.simpleAsyncFetchDataDemo") &#125; /// 这是一个通过url异步读取一个字符串内容的方法 /// /// - Parameters: /// - url: 目标url /// - completion: 读取完成回调block func fetchData(forUrl url: String, completion: @escaping (String) -&gt; Void) -&gt; Void &#123; self.queue.async &#123; sleep(2) // 这里让线程sleep 2秒模拟网络请求过程 let mockString = "This is content from server." completion(mockString) &#125; &#125;&#125;// 测试代码let demo = SimpleAsyncFetchDataDemo()demo.fetchData(forUrl: "https://apple.com/store/list") &#123; (data: String) in print("Data from server: \(data)")&#125; 上面的代码是一个非常理想的场景，即没有任何错误，下面让我们对它进行一点扩展，让它能够处理请求超时的情况。 第1种实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class SimpleAsyncFetchDataDemo &#123; enum FetchDataDemoError: Error &#123; case requestTimeoutError &#125; var queue: DispatchQueue init() &#123; self.queue = DispatchQueue(label: "com.wooy.swift.simpleAsyncFetchDataDemo") &#125; /// 这是一个通过url异步读取一个字符串内容的方法 /// /// - Parameters: /// - url: 目标url /// - completion: 读取完成回调block func fetchData(forUrl url: String, completion: @escaping (FetchDataDemoError?, String?) -&gt; Void) -&gt; Void &#123; self.queue.async &#123; [unowned self] in sleep(2) // 这里让线程sleep 2秒模拟网络请求过程 if self.isRequestTimeout &#123; completion(.requestTimeoutError, nil) &#125; else &#123; let mockString = "This is content from server." completion(nil, mockString) &#125; &#125; &#125; /// 这是一个请求是否超时的mock方法 final var isRequestTimeout: Bool &#123; return Bool.random() &#125;&#125;// 测试代码let demo = SimpleAsyncFetchDataDemo()demo.fetchData(forUrl: "https://apple.com/store/list") &#123; (error: SimpleAsyncFetchDataDemo.FetchDataDemoError?, data: String?) in if let error = error &#123; // 处理错误 print("Fetch data fail: \(error)") &#125; else &#123; if let data = data &#123; print("Data from server: \(data)") &#125; &#125;&#125; 这里我们对fetchData方法的completion参数进行了修改，把它从(String) -&gt; Void类型变成了(FetchDataDemoError?, String?) -&gt; Void类型，FetchDataDemoError是定义的fetchData的错误枚举类型。请求结束，有可能有错误，有可能没错误，因此需要定义成Optional类型(结果也是一样)。在定义callback的地方，我们需要先判断是否存在错误，存在错误优先处理错误，不存在错误则处理返回内容。 这是典型的OC的错误回调方法，通过把错误包装成一个回调block的参数，传给调用方。但是在Swift中，我们有了统一的错误处理机制，让我们使用错误处理机制来实现它。 第2种实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class SimpleAsyncFetchDataDemo &#123; enum FetchDataDemoError: Error &#123; case requestTimeoutError &#125; var queue: DispatchQueue init() &#123; self.queue = DispatchQueue(label: "com.wooy.swift.simpleAsyncFetchDataDemo") &#125; /// 这是一个通过url异步读取一个字符串内容的方法 /// /// - Parameters: /// - url: 目标url /// - completion: 读取完成回调block func fetchData(forUrl url: String, completion: @escaping (() throws -&gt; String) -&gt; Void) -&gt; Void &#123; self.queue.async &#123; [unowned self] in sleep(2) // 这里让线程sleep 2秒模拟网络请求过程 if self.isRequestTimeout &#123; completion(&#123; throw FetchDataDemoError.requestTimeoutError &#125;) // 传入一个抛出异常的block &#125; else &#123; let mockString = "This is content from server." completion(&#123; mockString &#125;) // 传入一个返回正常String的block &#125; &#125; &#125; /// 这是一个请求是否超时的mock方法 final var isRequestTimeout: Bool &#123; return Bool.random() &#125;&#125;// 测试代码let demo = SimpleAsyncFetchDataDemo()demo.fetchData(forUrl: "https://apple.com/store/list") &#123; // catching是第23或26行传入的block (catching: () throws -&gt; String) in do &#123; let data = try catching() print("Data from server: \(data)") &#125; catch let e where e is SimpleAsyncFetchDataDemo.FetchDataDemoError &#123; print("Fetch data fail: \(e)") &#125; catch &#123; print("Some other error: \(error)") &#125;&#125; 这里我们再次对completion参数进行了修改，从(FetchDataDemoError?, String?) -&gt; Void，改成了(() throws -&gt; String) -&gt; Void，即原来调用completion传入的参数，要不是某一个错误，或者是一个结果字符串，现在的入参变成了一个block，这个block是一个无入参，但是调用返回String类型，并且可能抛出异常的block。首先我们看fetchData方法内，现在是怎么传递内容/错误的。在第23行，我们返回了一个抛出异常的block，在第26行我们返回了一个返回正常String的block，分别对应请求超时和正常请求两种情况。然后让我们看看测试部分代码，首先catching是block，通过调用try catching()获取请求返回的内容，如果没有错误，则data会被赋值，即请求返回内容会给data；如果抛出错误则会被catch语句捕获，并在catch语句中处理响应的错误。 上面我们已经实现了异步block内错误的抛出，而Result主要就是用来简化我们第2个版本代码的，下面介绍Result的用法。 Result的使用接着用上面的例子，我们把completionblock的入参修改为(Result&lt;String, FetchDataDemoError&gt;) -&gt; Void，其中Result里面的类型必须显示声明，String代表success关联值的类型，FetchDataDemoError代表failure关联值的类型(这里可以把错误类型定义成更通用的Error类型，在使用的地方去做向上转型即可)。在请求超时的地方，我们通过result = .failure(.requestTimeoutError)为失败的关联值赋值，在请求成功的地方，我们通过result = .success(mockString)为成功的关联值类型赋值。 在使用的地方，我们可以通过switch语句提取值和处理错误，也可以使用和上面一样的do try catch语句提取值和处理错误。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class SimpleAsyncFetchDataDemo &#123; enum FetchDataDemoError: Error &#123; case requestTimeoutError &#125; var queue: DispatchQueue init() &#123; self.queue = DispatchQueue(label: "com.wooy.swift.simpleAsyncFetchDataDemo") &#125; /// 这是一个通过url异步读取一个字符串内容的方法 /// /// - Parameters: /// - url: 目标url /// - completion: 读取完成回调block func fetchData(forUrl url: String, completion: @escaping (Result&lt;String, FetchDataDemoError&gt;) -&gt; Void) &#123; self.queue.async &#123; [unowned self] in sleep(2) // 这里让线程sleep 2秒模拟网络请求过程 var result: Result&lt;String, FetchDataDemoError&gt; if self.isRequestTimeout &#123; result = .failure(.requestTimeoutError) // 为关联值附上错误 completion(result) &#125; else &#123; let mockString = "This is content from server." result = .success(mockString) // 为关联值附上成功响应的内容 completion(result) &#125; &#125; &#125; /// 这是一个请求是否超时的mock方法 final var isRequestTimeout: Bool &#123; return Bool.random() &#125;&#125;// 测试代码let demo = SimpleAsyncFetchDataDemo()demo.fetchData(forUrl: "https://apple.com/store/list") &#123; (result: Result&lt;String, SimpleAsyncFetchDataDemo.FetchDataDemoError&gt;) in // 写法一 switch result &#123; case .success(let data): print("Data from server: \(data)") break case .failure(let e): print("Fetch data fail: \(e)") break &#125; // 写法二 do &#123; let data = try result.get() print("Data from server: \(data)") &#125; catch let e where e is SimpleAsyncFetchDataDemo.FetchDataDemoError &#123; print("Fetch data fail: \(e)") &#125; catch &#123; print("Some other error: \(error)") &#125;&#125; 看了上面代码，不难发现其实Result的实现其实非常简单，和我们上面的第2种实现并无本质区别。但是它很好的展示了Swift中enum关联值类型的用法，这个抽象思维非常值得借鉴学习。下面是模仿Result接口的简单实现类似功能的MyResult。 12345678910111213enum MyResult&lt;Success, Failure: Error&gt; &#123; case success(Success) case failure(Failure) func get() throws -&gt; Success &#123; switch self &#123; case .success(let s): return s case .failure(let e): throw e &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
</search>
